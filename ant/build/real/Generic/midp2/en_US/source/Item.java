//#condition polish.usePolishGui
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2003, 2004 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
// package de.enough.polish.ui;

import java.io.IOException;

import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;
//#if polish.blackberry
	//# import net.rim.device.api.ui.Field;
//#endif

//import de.enough.polish.util.ArrayList;
//import de.enough.polish.util.HashMap;


/**
 * A superclass for components that can be added to a Form.
 * 
 * <p>Items support following CSS attributes:
 * </p>
 * <ul>
 * 		<li><b>margin, margin-left, margin-right, margin-top, margin-bottom, margin-vertical, margin-horizontal</b>: margins between border and next item.</li>
 * 		<li><b>padding, padding-left, padding-right, padding-top, padding-bottom, padding-vertical, padding-horizontal</b>: paddings between border and content.</li>
 * 		<li><b>background</b>: The background of this item.</li>
 * 		<li><b>border</b>: The border of this item.</li>
 * 		<li><b>min-width</b>: The minimum width of this item.</li>
 * 		<li><b>max-width</b>: The maximum width of this item.</li>
 * 		<li><b>min-height</b>: The minimum height of this item.</li>
 * 		<li><b>max-height</b>: The maximum height of this item.</li>
 * 		<li><b>before</b>: URL of image that should be placed before this item.</li>
 * 		<li><b>after</b>: URL of image that should be placed after this item.</li>
 * 		<li><b>include-label</b>: set to true when the background and border should include the label of this item as well.</li>
 * 		<li><b>colspan</b>: when this item is embedded in a table, you can span it over several cells, e.g. colspan: 2;.</li>
 * 		<li><b>label-style</b>: The name of the specialized label style for this item, e.g. "label-style: funnyLabel;"</li>
 * 		<li><b>focused-style</b>: The name of the specialized focused style for this item, e.g. "focused-style: funnyFocused;"</li>
 * 		<li><b>view-type</b>: The view of this item.</li>
 * </ul>
 * 
 * A superclass for components that can be added to a <A HREF="../../../javax/microedition/lcdui/Form.html"><CODE>Form</CODE></A>. All <code>Item</code> objects have a label field,
 * which is a string that is
 * attached to the item. The label is typically displayed near the component
 * when it is displayed within a screen.  The label should be positioned on
 * the same horizontal row as the item or
 * directly above the item.  The implementation should attempt to distinguish
 * label strings from other textual content, possibly by displaying the label
 * in a different font, aligning it to a different margin, or appending a
 * colon to it if it is placed on the same line as other string content.
 * If the screen is scrolling, the implementation should try
 * to keep the label visible at the same time as the <code>Item</code>.
 * 
 * <p>In some cases,
 * when the user attempts to interact with an <code>Item</code>,
 * the system will switch to
 * a system-generated screen where the actual interaction takes place. If
 * this occurs, the label will generally be carried along and displayed within
 * this new screen in order to provide the user with some context for the
 * operation. For this reason it is recommended that applications supply a
 * label to all interactive Item objects. However, this is not required, and
 * a <code>null</code> value for a label is legal and specifies
 * the absence of a label.
 * </p>
 * 
 * <h3>Item Layout</h3>
 * 
 * <p>An <code>Item's</code> layout within its container is
 * influenced through layout directives:</p>
 * 
 * <ul>
 * <li> <code>LAYOUT_DEFAULT</code> </li>
 * <li> <code>LAYOUT_LEFT</code> </li>
 * <li> <code>LAYOUT_RIGHT</code> </li>
 * <li> <code>LAYOUT_CENTER</code> </li>
 * <li> <code>LAYOUT_TOP</code> </li>
 * <li> <code>LAYOUT_BOTTOM</code> </li>
 * <li> <code>LAYOUT_VCENTER</code> </li>
 * <li> <code>LAYOUT_NEWLINE_BEFORE</code> </li>
 * <li> <code>LAYOUT_NEWLINE_AFTER</code> </li>
 * <li> <code>LAYOUT_SHRINK</code> </li>
 * <li> <code>LAYOUT_VSHRINK</code> </li>
 * <li> <code>LAYOUT_EXPAND</code> </li>
 * <li> <code>LAYOUT_VEXPAND</code> </li>
 * <li> <code>LAYOUT_2</code> </li>
 * </ul>
 * 
 * <p>The <code>LAYOUT_DEFAULT</code> directive indicates
 * that the container's default
 * layout policy is to be used for this item.
 * <code>LAYOUT_DEFAULT</code> has the value
 * zero and has no effect when combined with other layout directives.  It is
 * useful within programs in order to document the programmer's intent.</p>
 * 
 * <p>The <code>LAYOUT_LEFT</code>, <code>LAYOUT_RIGHT</code>, and
 * <code>LAYOUT_CENTER</code> directives indicate
 * horizontal alignment and are mutually exclusive.  Similarly, the
 * <code>LAYOUT_TOP</code>, <code>LAYOUT_BOTTOM</code>, and
 * <code>LAYOUT_VCENTER</code> directives indicate vertical
 * alignment and are mutually exclusive.</p>
 * 
 * <p>A horizontal alignment directive, a vertical alignment directive, and
 * any combination of other layout directives may be combined using the
 * bit-wise <code>OR</code> operator (<code>|</code>) to compose a
 * layout directive value.  Such a value
 * is used as the parameter to the <A HREF="../../../javax/microedition/lcdui/Item.html#setLayout(int)"><CODE>setLayout(int)</CODE></A> method and is the return
 * value from the <A HREF="../../../javax/microedition/lcdui/Item.html#getLayout()"><CODE>getLayout()</CODE></A> method.</p>
 * 
 * <p>Some directives have no defined behavior in some contexts.  A layout
 * directive is ignored if its behavior is not defined for the particular
 * context within which the <code>Item</code> resides.</p>
 * 
 * <p>A complete specification of the layout of <code>Items</code>
 * within a <code>Form</code> is given
 * <a href="Form.html#layout">here</a>.</p>
 * 
 * <a name="sizes"></a>
 * <h3>Item Sizes</h3>
 * 
 * <p><code>Items</code> have two explicit size concepts: the <em>minimum</em>
 * size and the
 * <em>preferred</em> size.  Both the minimum and the preferred sizes refer to
 * the total area of the <code>Item</code>, which includes space for the
 * <code>Item's</code> contents,
 * the <code>Item's</code> label, as well as other space that is
 * significant to the layout
 * policy.  These sizes do not include space that is not significant for
 * layout purposes.  For example, if the addition of a label to an
 * <code>Item</code> would
 * cause other <code>Items</code> to move in order to make room,
 * then the space occupied by
 * this label is significant to layout and is counted as part of
 * the <code>Item's</code>
 * minimum and preferred sizes.  However, if an implementation were to place
 * the label in a margin area reserved exclusively for labels, this would not
 * affect the layout of neighboring <code>Items</code>.
 * In this case, the space occupied
 * by the label would not be considered part of the minimum and preferred
 * sizes.</p>
 * 
 * <p>The minimum size is the smallest size at which the
 * <code>Item</code> can function and
 * display its contents, though perhaps not optimally.  The minimum size
 * may be recomputed whenever the <code>Item's</code> contents changes.</p>
 * 
 * <p>The preferred size is generally a size based on the
 * <code>Item's</code> contents and
 * is the smallest size at which no information is clipped and text wrapping
 * (if any) is kept to a tolerable minimum.  The preferred size may be
 * recomputed whenever the <code>Item's</code> contents changes.
 * The application can
 * <em>lock</em> the preferred width or preferred height (or both) by
 * supplying specific values for parameters to the <A HREF="../../../javax/microedition/lcdui/Item.html#setPreferredSize(int, int)"><CODE>setPreferredSize</CODE></A> method.  The manner in which an
 * <code>Item</code> fits its contents
 * within an application-specified preferred size is implementation-specific.
 * However, it is recommended that textual content be word-wrapped to fit the
 * preferred size set by the application.  The application can <em>unlock</em>
 * either or both dimensions by supplying the value <code>-1</code>
 * for parameters to the <code>setPreferredSize</code> method.</p>
 * 
 * <p>When an <code>Item</code> is created, both the preferred width
 * and height are
 * unlocked.  In this state, the implementation computes the preferred width
 * and height based on the <code>Item's</code> contents, possibly
 * including other relevant
 * factors such as the <code>Item's</code> graphic design and the
 * screen dimensions.
 * After having locked either the preferred width or height, the application
 * can restore the initial, unlocked state by calling
 * <code>setPreferredSize(-1,&nbsp;-1)</code>.</p>
 * 
 * <p>The application can lock one dimension of the preferred size and leave
 * the other unlocked.  This causes the system to compute an appropriate value
 * for the unlocked dimension based on arranging the contents to fit the
 * locked dimension.  If the contents changes, the size on the unlocked
 * dimension is recomputed to reflect the new contents, but the size on the
 * locked dimension remains unchanged.  For example, if the application called
 * <code>setPreferredSize(50,&nbsp;-1)</code>, the preferred width would be
 * locked at <code>50</code> pixels and the preferred height would
 * be computed based on the
 * <code>Item's</code> contents.  Similarly, if the application called
 * <code>setPreferredSize(-1,&nbsp;60)</code>, the preferred height would be
 * locked at <code>60</code> pixels and the preferred width would be
 * computed based on the
 * <code>Item's</code> contents.  This feature is particularly useful
 * for <code>Items</code> with
 * textual content that can be line wrapped.</p>
 * 
 * <p>The application can also lock both the preferred width and height to
 * specific values.  The <code>Item's</code> contents are truncated or padded
 * as necessary to honor this request.  For <code>Items</code> containing
 * text, the text should be wrapped to the specified width, and any truncation
 * should occur at the end of the text.</p>
 * 
 * <p><code>Items</code> also have an implicit maximum size provided by the
 * implementation.  The maximum width is typically based on the width of the
 * screen space available to a <code>Form</code>.  Since <code>Forms</code>
 * can scroll vertically, the maximum height should typically not be based on
 * the height of the available screen space.</p>
 * 
 * <p>If the application attempts to lock a preferred size dimension to a
 * value smaller than the minimum or larger than the maximum, the
 * implementation may disregard the requested value and instead use either the
 * minimum or maximum as appropriate.  If this occurs, the actual values used
 * must be visible to the application via the values returned from the
 * <A HREF="../../../javax/microedition/lcdui/Item.html#getPreferredWidth()"><CODE>getPreferredWidth</CODE></A> and
 * <A HREF="../../../javax/microedition/lcdui/Item.html#getPreferredHeight()"><CODE>getPreferredHeight</CODE></A> methods.
 * </p>
 * 
 * <h3>Commands</h3>
 * 
 * <p>A <code>Command</code> is said to be present on an <code>Item</code>
 * if the <code>Command</code> has been
 * added to this <code>Item</code> with a prior call to <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
 * or <A HREF="../../../javax/microedition/lcdui/Item.html#setDefaultCommand(javax.microedition.lcdui.Command)"><CODE>setDefaultCommand(javax.microedition.lcdui.Command)</CODE></A> and if
 * the <code>Command</code> has not been removed with a subsequent call to
 * <A HREF="../../../javax/microedition/lcdui/Item.html#removeCommand(javax.microedition.lcdui.Command)"><CODE>removeCommand(javax.microedition.lcdui.Command)</CODE></A>.  <code>Commands</code> present on an
 * item should have a command
 * type of <code>ITEM</code>.  However, it is not an error for a
 * command whose type is
 * other than <code>ITEM</code> to be added to an item.
 * For purposes of presentation and
 * placement within its user interface, the implementation is allowed to
 * treat a command's items as if they were of type <code>ITEM</code>. </p>
 * 
 * <p><code>Items</code> may have a <em>default</em> <code>Command</code>.
 * This state is
 * controlled by the <A HREF="../../../javax/microedition/lcdui/Item.html#setDefaultCommand(javax.microedition.lcdui.Command)"><CODE>setDefaultCommand(javax.microedition.lcdui.Command)</CODE></A> method.  The default
 * <code>Command</code> is eligible to be bound to a special
 * platform-dependent user
 * gesture.  The implementation chooses which gesture is the most
 * appropriate to initiate the default command on that particular
 * <code>Item</code>.
 * For example, on a device that has a dedicated selection key, pressing
 * this key might invoke the item's default command.  Or, on a
 * stylus-based device, tapping on the <code>Item</code> might
 * invoke its default
 * command.  Even if it can be invoked through a special gesture, the
 * default command should also be invokable in the same fashion as
 * other item commands.</p>
 * 
 * <p>It is possible that on some devices there is no special gesture
 * suitable for invoking the default command on an item.  In this case
 * the default command must be accessible to the user in the same
 * fashion as other item commands.  The implementation may use the state
 * of a command being the default in deciding where to place the command
 * in its user interface.</p>
 * 
 * <p>It is possible for an <code>Item</code> not to have a default command.
 * In this
 * case, the implementation may bind its special user gesture (if any)
 * for another purpose, such as for displaying a menu of commands.  The
 * default state of an <code>Item</code> is not to have a default command.
 * An <code>Item</code>
 * may be set to have no default <code>Command</code> by removing it from
 * the <code>Item</code> or
 * by passing <code>null</code> to the <code>setDefaultCommand()</code>
 * method.</p>
 * 
 * <p>The same command may occur on more than one
 * <code>Item</code> and also on more than
 * one <code>Displayable</code>.  If this situation occurs, the user
 * must be provided with
 * distinct gestures to invoke that command on each <code>Item</code> or
 * <code>Displayable</code> on
 * which it occurs, while those <code>Items</code> or <code>Displayables</code>
 * are visible on the
 * display.  When the user invokes the command, the listener
 * (<code>CommandListener</code>
 * or <code>ItemCommandListener</code> as appropriate) of just the
 * object on which the
 * command was invoked will be called.</p>
 * 
 * <p>Adding commands to an <code>Item</code> may affect its appearance, the
 * way it is laid out, and the traversal behavior.  For example, the presence
 * of commands on an <code>Item</code> may cause row breaks to occur, or it
 * may cause additional graphical elements (such as a menu icon) to appear.
 * In particular, if a <code>StringItem</code> whose appearance mode is
 * <code>PLAIN</code> (see below) is given one or more <code>Commands</code>,
 * the implementation is allowed to treat it as if it had a different
 * appearance mode.</p>
 * 
 * <p>J2ME Polish notifies the command-listener of the current screen,
 * when an item-command has been selected and no item-command-listener
 * has been registered.
 * </p>
 * 
 * <a name="appearance"></a>
 * <h3>Appearance Modes</h3>
 * 
 * <p>The <code>StringItem</code> and <code>ImageItem</code> classes have an
 * <em>appearance mode</em> attribute that can be set in their constructors.
 * This attribute can have one of the values <A HREF="../../../javax/microedition/lcdui/Item.html#PLAIN"><CODE>PLAIN</CODE></A>,
 * <A HREF="../../../javax/microedition/lcdui/Item.html#HYPERLINK"><CODE>HYPERLINK</CODE></A>, or <A HREF="../../../javax/microedition/lcdui/Item.html#BUTTON"><CODE>BUTTON</CODE></A>.
 * An appearance mode of <code>PLAIN</code> is typically used
 * for non-interactive
 * display of textual or graphical material.  The appearance
 * mode values do not have any side effects on the interactivity of the item.
 * In order to be interactive, the item must have one or more
 * <code>Commands</code>
 * (preferably with a default command assigned), and it must have a
 * <code>CommandListener</code> that receives notification of
 * <code>Command</code> invocations.  The
 * appearance mode values also do not have any effect on the semantics of
 * <code>Command</code> invocation on the item.  For example,
 * setting the appearance mode
 * of a <code>StringItem</code> to be <code>HYPERLINK</code>
 * requests that the implementation display
 * the string contents as if they were a hyperlink in a browser.  It is the
 * application's responsibility to attach a <code>Command</code>
 * and a listener to the
 * <code>StringItem</code> that provide behaviors that the user
 * would expect from invoking
 * an operation on a hyperlink, such as loading the referent of the link or
 * adding the link to the user's set of bookmarks.</p>
 * 
 * <p>Setting the appearance mode of an <code>Item</code> to be other than
 * <code>PLAIN</code> may affect its minimum, preferred, and maximum sizes, as
 * well as the way it is laid out.  For example, a <code>StringItem</code>
 * with an appearance mode of <code>BUTTON</code> should not be wrapped across
 * rows.  (However, a <code>StringItem</code> with an appearance mode of
 * <code>HYPERLINK</code> should be wrapped the same way as if its appearance
 * mode is <code>PLAIN</code>.)</p>
 * 
 * <p>A <code>StringItem</code> or <code>ImageItem</code>
 * in <code>BUTTON</code> mode can be used to create a
 * button-based user interface.  This can easily lead to applications that are
 * inconvenient to use.  For example, in a traversal-based system, users must
 * navigate to a button before they can invoke any commands on it.  If buttons
 * are spread across a long <code>Form</code>, users may be required
 * to perform a
 * considerable amount of navigation in order to discover all the available
 * commands.  Furthermore, invoking a command from a button at the
 * other end of the <code>Form</code> can be quite cumbersome.
 * Traversal-based systems
 * often provide a means of invoking commands from anywhere (such as from a
 * menu), without the need to traverse to a particular item.  Instead of
 * adding a command to a button and placing that button into a
 * <code>Form</code>, it would
 * often be more appropriate and convenient for users if that command were
 * added directly to the <code>Form</code>.  Buttons should be used
 * only in cases where
 * direct user interaction with the item's string or image contents is
 * essential to the user's understanding of the commands that can be invoked
 * from that item.</p>
 * 
 * <h3>Default State</h3>
 * 
 * <p>Unless otherwise specified by a subclass, the default state of newly
 * created <code>Items</code> is as follows:</p>
 * 
 * <ul>
 * <li>the <code>Item</code> is not contained within
 * (&quot;owned by&quot;) any container;</li>
 * <li>there are no <code>Commands</code> present;</li>
 * <li>the default <code>Command</code> is <code>null</code>;</li>
 * <li>the <code>ItemCommandListener</code> is <code>null</code>;</li>
 * <li>the layout directive value is <code>LAYOUT_DEFAULT</code>; and</li>
 * <li>both the preferred width and preferred height are unlocked.</li>
 * </ul>
 * 
 * @since MIDP 1.0
 */
public abstract class Item extends Object
{
	/**
	 * A J2ME Polish constant defining a transparent/invisible color.
	 * TRANSPARENT has the value -1.
	 */
	public static final int TRANSPARENT = -1;
	
	/**
	 * A J2ME Polish constant defining a vertical orientation.
	 * VERTICAL has the value 0.
	 */
	public static final int VERTICAL = 0;
	
	/**
	 * A J2ME Polish constant defining a horizontal orientation.
	 * HORIZONTAL has the value 1.
	 */
	public static final int HORIZONTAL = 1;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should follow the default layout policy of its container.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>LAYOUT_DEFAULT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_DEFAULT = 0;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * left-aligned layout.
	 * 
	 * <P>Value <code>1</code> is assigned to <code>LAYOUT_LEFT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_LEFT = 1;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * right-aligned layout.
	 * 
	 * <P>Value <code>2</code> is assigned to <code>LAYOUT_RIGHT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_RIGHT = 2;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * horizontally centered layout.
	 * 
	 * <P>Value <code>3</code> is assigned to <code>LAYOUT_CENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_CENTER = 3;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * top-aligned layout.
	 * 
	 * <P>Value <code>0x10</code> is assigned to <code>LAYOUT_TOP</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_TOP = 0x10;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * bottom-aligned layout.
	 * 
	 * <P>Value <code>0x20</code> is assigned to <code>LAYOUT_BOTTOM</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_BOTTOM = 0x20;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * vertically centered layout.
	 * 
	 * <P>Value <code>0x30</code> is assigned to
	 * <code>LAYOUT_VCENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VCENTER = 0x30;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should be placed at the beginning of a new line or row.
	 * 
	 * <P>Value <code>0x100</code> is assigned to
	 * <code>LAYOUT_NEWLINE_BEFORE</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_BEFORE = 0x100;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should the last on its line or row, and that the next
	 * <code>Item</code> (if any) in the container
	 * should be placed on a new line or row.
	 * 
	 * <P>Value <code>0x200</code> is assigned to
	 * <code>LAYOUT_NEWLINE_AFTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_AFTER = 0x200;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be reduced to its minimum width.
	 * 
	 * <P>Value <code>0x400</code> is assigned to <code>LAYOUT_SHRINK</code></P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_SHRINK = 0x400;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be increased to fill available space.
	 * 
	 * <P>Value <code>0x800</code> is assigned to <code>LAYOUT_EXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_EXPAND = 0x800;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be reduced to its minimum height.
	 * 
	 * <P>Value <code>0x1000</code> is assigned to
	 * <code>LAYOUT_VSHRINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VSHRINK = 0x1000;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be increased to fill available space.
	 * 
	 * <P>Value <code>0x2000</code> is assigned to
	 * <code>LAYOUT_VEXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VEXPAND = 0x2000;

	/**
	 * A layout directive indicating that new MIDP 2.0 layout
	 * rules are in effect for this <code>Item</code>.  If this
	 * bit is clear, indicates that MIDP 1.0 layout behavior
	 * applies to this <code>Item</code>.
	 * 
	 * <P>Value <code>0x4000</code> is assigned to
	 * <code>LAYOUT_2</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_2 = 0x4000;

	/**
	 * An appearance mode value indicating that the <code>Item</code> is to have
	 * a normal appearance.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>PLAIN</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int PLAIN = 0;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a hyperlink.
	 * <P>Value <code>1</code> is assigned to <code>HYPERLINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int HYPERLINK = 1;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a button.
	 * <P>Value <code>2</code> is assigned to <code>BUTTON</code>.</P>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int BUTTON = 2;

	/**
	 * A J2ME Polish appearance mode value indicating that the <code>Item</code>
	 * accepts input from the user.
	 * <P>Value <code>3</code> is assigned to <code>INTERACTIVE</code>.</P>
	 */
	public static final int INTERACTIVE = 3;
	
	protected int layout;
	protected ItemCommandListener itemCommandListener;
	protected Command defaultCommand;
	protected int preferredWidth;
	protected int preferredHeight;
	protected int minimumWidth;
	protected int minimumHeight;
	//#ifdef polish.css.max-width
		//# protected int maximumWidth;
	//#endif
	//#ifdef polish.css.max-height
		//# protected int maximumHeight;
	//#endif
	protected boolean isInitialized;
	public Background background;
	protected Border border;
	protected Style style;
	public int itemWidth;
	public int itemHeight;
	protected int paddingLeft;
	protected int paddingTop;
	protected int paddingRight;
	protected int paddingBottom;
	protected int paddingVertical;
	protected int paddingHorizontal;
	protected int marginLeft;
	protected int marginTop;
	protected int marginRight;
	protected int marginBottom;
	/** The width of this item's content **/
	protected int contentWidth;
	/** The height of this item's content **/
	protected int contentHeight;
	protected int borderWidth;
	protected int backgroundWidth;
	protected int backgroundHeight;
	/** The appearance mode of this item, either PLAIN or one of the interactive modes BUTTON, HYPERLINK or INTERACTIVE. */
	public int appearanceMode;
	/**
	 * The screen to which this item belongs to.
	 */
	protected Screen screen;
	//#ifdef polish.useDynamicStyles
		//# /**
		 //# * The appropriate CSS selector of this item. 
		 //# * This is either the style's name or a selector
		 //# * depending on the state of this item. A StringItem
		 //# * can have the selector "p", "a" or "button", for example.
		 //# * This variable can only be used, when the proprocessing variable
		 //# * "polish.useDynamicStyles" is defined.
		 //# */
		//# protected String cssSelector;
	//#endif
	/**
	 * Determines whether the style has be dynamically assigned already.
	 */
	protected boolean isStyleInitialised;
	/**
	 * The parent of this item.
	 */
	protected Item parent;

	protected ArrayList commands;
	
	protected boolean isLayoutCenter;
	protected boolean isLayoutExpand;
	protected boolean isLayoutRight;
	// the current positions of this item:
	/** the horizontal start position relative to it's parent's item left content edge */
	public int relativeX;
	/** the vertical start position of this item relative to it's parent item top content edge */
	public int relativeY; 
	/** the horizontal position of this item's content relative to it's left edge */
	protected int contentX;
	/** the vertical position of this item's content relative to it's top edge */
	protected int contentY; // absolute top vertical position of the content 
	// the current positions of an internal element relative to the content origin 
	// which should be visible:
	/** 
	 * The internal horizontal position of this item's content relative to it's left edge. 
	 * When it is equal -9999 this item's internal position is not known.
	 * The internal position is useful for items that have a large content which
	 * needs to be scrolled, e.g. containers.  
	 */
	protected int internalX = -9999;
	/** the vertical position of this item's internal content relative to it's top edge */
	protected int internalY;
	/** The internal width of this item's content.  */
	protected int internalWidth;
	/** The internal height of this item's content.  */
	protected int internalHeight;
	public boolean isFocused;
	
	//#ifdef polish.css.before
		//# private String beforeUrl;
		//# private int beforeWidth;
		//# private int beforeHeight;
		//# private Image beforeImage;
	//#endif

	//#ifdef polish.css.after
		//# private String afterUrl;
		//# private int afterWidth;
		//# private int afterHeight;
		//# private Image afterImage;
	//#endif
	// label settings:
	protected Style labelStyle = StyleSheet.labelStyle;
	protected StringItem label;
	private boolean useSingleRow;
	//#if polish.blackberry
		//# public Field _bbField;
		//# public boolean _bbFieldAdded;
	//#endif
	protected Style focusedStyle;

	//#if polish.css.colspan
		//# protected int colSpan = 1;
	//#endif
	//#if polish.css.rowspan
		//# protected int rowSpan;
	//#endif
	//#if polish.css.include-label
		//# protected boolean includeLabel;
	//#endif
	/** The vertical offset for the background, can be used for smoother scrolling, for example */ 
	protected int backgroundYOffset;

	private HashMap attributes;

	//#ifdef polish.css.view-type
		protected ItemView view;
	//#endif

	
	protected Item() {
		this( null, LAYOUT_DEFAULT, PLAIN, null );
	}
	
	protected Item( Style style ) {
		this( null, LAYOUT_DEFAULT, PLAIN, style );
	}
	
	protected Item( String label, int layout) {
		this( label, layout, PLAIN, null );
	}

	/**
	 * Creates a new Item.
	 * 
	 * @param label the label of this item
	 * @param layout the layout of this item
	 * @param appearanceMode the mode of this item, either Item.PLAIN, Item.BUTTON or Item.HYPERLINK
	 * @param style the style of this item - contains the background, border etc.
	 */
	protected Item(String label, int layout, int appearanceMode, Style style) {
		this.style = style;
		this.layout = layout;
		this.appearanceMode = appearanceMode;
		if (label != null && label.length() != 0) {
			setLabel( label );
		}
		if (style == null) {
			this.layout = layout;
		} else {
			this.style = style;
			this.isStyleInitialised = false;
		}
	}

	/**
	 * Sets the label of the <code>Item</code>. If <code>label</code>
	 * is <code>null</code>, specifies that this item has no label.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param label - the label string
	 * @throws IllegalStateException - if this Item is contained  within an Alert
	 * @see #getLabel()
	 */
	public void setLabel( String label)
	{
		if (this.label == null) {
			this.label = new StringItem( null, label, this.labelStyle );
			this.label.parent = this.parent;
		} else {
			this.label.setText( label );
		}
		if (this.isInitialized) {
			this.isInitialized = false;
			repaint();
		}
	}

	/**
	 * Gets the label of this <code>Item</code> object.
	 * 
	 * @return the label string
	 * @see #setLabel(java.lang.String)
	 */
	public String getLabel()
	{
		if (this.label == null) {
			return null;
		} else {
			return this.label.getText();
		}
	}
	
	/**
	 * Retrieves the label item that is used by this item.\
	 * 
	 * @return the item or null when no item is used.
	 */
	public Item getLabelItem() {
		return this.label;
	}

	/**
	 * Gets the layout directives used for placing the item.
	 * 
	 * @return a combination of layout directive values
	 * @see #setLayout(int)
	 * @since  MIDP 2.0
	 */
	public int getLayout()
	{
		return this.layout;
	}

	/**
	 * Sets the layout directives for this item.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param layout - a combination of layout directive values for this item
	 * @throws IllegalArgumentException - if the value of layout is not a bit-wise OR combination of layout directives
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getLayout()
	 * @since  MIDP 2.0
	 */
	public void setLayout(int layout)
	{
		if (layout != this.layout) {
			this.layout = layout;
			if (this.isInitialized) {
				this.isInitialized = false;
				repaint();
			}
		}
	}

	/**
	 * Returns the appearance mode of this <code>Item</code>.
	 * See <a href="Item.html#appearance">Appearance Modes</a>.
	 * 
	 * @return the appearance mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 * @since  MIDP 2.0
	 */
	public int getAppearanceMode()
	{
		return this.appearanceMode;
	}
	
	/**
	 * Sets the appearance mode of this item.
	 * 
	 * @param appearanceMode the mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 */
	public void setAppearanceMode( int appearanceMode ) {
		this.appearanceMode = appearanceMode;
	}
	
	/**
	 * Retrieves the style of this item.
	 * 
	 * @return the style of this item.
	 */
	public Style getStyle() {
		return this.style;
	}
	
	/**
	 * Sets the style of this item.
	 * 
	 * @param style the new style for this item.
	 * @throws NullPointerException when style is null
	 */
	public void setStyle( Style style ) {
		//#debug
		//# System.out.println("setting style - with background: " + (style.background != null));
		this.isInitialized = false;
		this.isStyleInitialised = true;
		this.style = style;
		if (style != StyleSheet.defaultStyle) {
			this.layout = style.layout;
		}
		// horizontal styles: center -> right -> left
		if ( ( this.layout & LAYOUT_CENTER ) == LAYOUT_CENTER ) {
			this.isLayoutCenter = true;
			this.isLayoutRight = false;
		} else {
			this.isLayoutCenter = false;
			if ( ( this.layout & LAYOUT_RIGHT ) == LAYOUT_RIGHT ) {
				this.isLayoutRight = true;
			} else {
				this.isLayoutRight = false;
			}
		}
		//System.out.println(" style [" + style.name + "]: right: " + this.isLayoutRight + " center: " + this.isLayoutCenter);
		// vertical styles: vcenter -> bottom -> top
		// expanding layouts:
		if ( ( this.layout & LAYOUT_EXPAND ) == LAYOUT_EXPAND ) {
			this.isLayoutExpand = true;
		} else {
			this.isLayoutExpand = false;
		}
		this.background = style.background;
		this.border = style.border;
		if (this.border != null) {
			this.borderWidth = this.border.borderWidth;
		} else if (this.background != null){
			this.borderWidth = this.background.borderWidth;
		} else {
			this.borderWidth = 0;
		}
		this.paddingLeft = style.paddingLeft;
		this.paddingRight = style.paddingRight;
		this.paddingTop = style.paddingTop;
		this.paddingBottom = style.paddingBottom;
		this.paddingVertical = style.paddingVertical;
		this.paddingHorizontal = style.paddingHorizontal;
		this.marginLeft = style.marginLeft;
		this.marginRight = style.marginRight;
		this.marginTop = style.marginTop;
		this.marginBottom = style.marginBottom;
		//#ifdef polish.css.before
			//# String beforeUrlStr = style.getProperty(190); 
			//# if (beforeUrlStr != null) {
				//# if ( !beforeUrlStr.equals(this.beforeUrl) ) {
					//# try {
						//# this.beforeImage = StyleSheet.getImage(beforeUrlStr, null, true );
						//# this.beforeWidth = this.beforeImage.getWidth() + this.paddingHorizontal;
						//# this.beforeHeight = this.beforeImage.getHeight();
					//# } catch (IOException e) {
						//# this.beforeUrl = null;
						//# this.beforeImage = null;
						//# this.beforeWidth = 0;
						//# this.beforeHeight = 0;						
					//# }
				//# }
			//# } else {
				//# this.beforeImage = null;
				//# this.beforeWidth = 0;
				//# this.beforeHeight = 0;
			//# }
			//# this.beforeUrl = beforeUrlStr;
		//#endif
		//#ifdef polish.css.after
			//# String afterUrlStr = style.getProperty(191);
			//# if (afterUrlStr != null) {
				//# if ( !afterUrlStr.equals(this.afterUrl) ) {
					//# try {
						//# this.afterImage = StyleSheet.getImage(afterUrlStr, null, true );
						//# this.afterWidth = this.afterImage.getWidth() + this.paddingHorizontal;
						//# this.afterHeight = this.afterImage.getHeight();
					//# } catch (IOException e) {
						//# this.afterUrl = null;
						//# this.afterWidth = 0;
						//# this.afterHeight = 0;
						//# this.afterImage = null;
					//# }
				//# }
			//# } else {
				//# this.afterWidth = 0;
				//# this.afterHeight = 0;
				//# this.afterImage = null;
			//# }
			//# this.afterUrl = afterUrlStr;
		//#endif
		//#ifdef polish.css.label-style
			//# Style labStyle = (Style) style.getObjectProperty(3);
			//# if (labStyle != null) {
				//# this.labelStyle = labStyle;
			//# } else if (this.labelStyle == null || this.isFocused) {
				//# this.labelStyle = StyleSheet.labelStyle;
			//# }
		//#else
			this.labelStyle = StyleSheet.labelStyle;
		//#endif
		if (this.label != null) {
			this.label.setStyle( this.labelStyle );			
		}
		//#ifdef polish.css.min-width
			//# Integer minWidthInt = style.getIntProperty(58);
			//# if (minWidthInt != null) {
				//# this.minimumWidth = minWidthInt.intValue();
			//# }
		//#endif
		//#ifdef polish.css.max-width
			//# Integer maxWidthInt  = style.getIntProperty(59);
			//# if (maxWidthInt != null) {
				//# this.maximumWidth = maxWidthInt.intValue();
			//# }
		//#endif
		//#ifdef polish.css.min-height
			//# Integer minHeightInt = style.getIntProperty(144);
			//# if (minHeightInt != null) {
				//# this.minimumHeight = minHeightInt.intValue();
			//# }
		//#endif
		//#ifdef polish.css.max-height
			//# Integer maxHeightInt  = style.getIntProperty(145);
			//# if (maxHeightInt != null) {
				//# this.maximumHeight = maxHeightInt.intValue();
			//# }
		//#endif
		//#ifdef polish.css.focused-style
			//Object object = style.getObjectProperty("focused-style");
			//if (object != null) {
			//	System.out.println("focused-type: " + object.getClass().getName());
			//}
			Style focused = (Style) style.getObjectProperty(1);
			if (focused != null) {
				this.focusedStyle = focused;
//				if (this instanceof ChoiceGroup) {
//					System.out.println("Setting focused style for choicegroup!");
//				}
			}
		//#endif
		//#if polish.css.colspan
			//# Integer colSpanInt = style.getIntProperty(106);
			//# if ( colSpanInt != null ) {
				//# this.colSpan = colSpanInt.intValue();
			//# }
		//#endif	
		//#if polish.css.include-label
			//# Boolean includeLabelBool = style.getBooleanProperty(132);
			//# if (includeLabelBool != null) {
				//# this.includeLabel = includeLabelBool.booleanValue();
			//# }
		//#endif
		//#ifdef polish.css.view-type
			ItemView viewType = (ItemView) style.getObjectProperty(39);
//			if (this instanceof ChoiceGroup) {
//				System.out.println("SET.STYLE / CHOICEGROUP: found view-type (1): " + (viewType != null) + " for " + this);
//			}
			if (viewType != null) {
				if (this.view == null || this.view.getClass() != viewType.getClass()) {
					try {
						if (viewType.parentItem != null) {
							viewType = (ItemView) viewType.getClass().newInstance();
						}
						viewType.parentItem = this;
						this.view = viewType;
					} catch (Exception e) {
						//#debug error
						//# System.out.println("Container: Unable to init view-type " + e );
						viewType = null;
					}
				}
			}
		//#endif
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.setStyle(style);
			}
		//#endif
	}
	
	/**
	 * Retrieves the complete width of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a StringItem gets a new text.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @return the complete width of this item.
	 */
	public int getItemWidth( int firstLineWidth, int lineWidth ) {
		if (!this.isInitialized || this.itemWidth > lineWidth) {
			init( firstLineWidth, lineWidth );
		}
		return this.itemWidth;
	}

	/**
	 * Retrieves the complete height of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a new style is set.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @return the complete heigth of this item.
	 */
	public int getItemHeight( int firstLineWidth, int lineWidth ) {
		if (!this.isInitialized || this.itemWidth > lineWidth) {
			init( firstLineWidth, lineWidth );
		}
		return this.itemHeight;
	}

	/**
	 * Adds a context sensitive <code>Command</code> to the item.
	 * The semantic type of
	 * <code>Command</code> should be <code>ITEM</code>. The implementation
	 * will present the command
	 * only when the item is active, for example, highlighted.
	 * <p>
	 * If the added command is already in the item (tested by comparing the
	 * object references), the method has no effect. If the item is
	 * actually visible on the display, and this call affects the set of
	 * visible commands, the implementation should update the display as soon
	 * as it is feasible to do so.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be added
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @throws NullPointerException if cmd is null
	 * @since  MIDP 2.0
	 */
	public void addCommand( Command cmd)
	{
		if (this.commands == null) {
			this.commands = new ArrayList();
		}
		if (!this.commands.contains( cmd )) {
			this.commands.add(cmd);
			if (this.appearanceMode == PLAIN) {
				this.appearanceMode = HYPERLINK;
			}
			if (this.isFocused) {
				Screen scr = getScreen();
				if (scr != null) {
					scr.addCommand( cmd );
				}
			}
			if (this.isInitialized) {
				repaint();
			}
		}
	}

	/**
	 * Repaints the complete screen to which this item belongs to.
	 * Subclasses can call this method whenever their contents
	 * have changed and they need an immediate refresh.
	 *  
	 * @see #repaint()
	 * @see #repaint(int, int, int, int)
	 */
	protected void repaintFully() {
		repaint( this.relativeX, this.relativeY, this.itemWidth, this.itemHeight );
		if (this.parent instanceof Container) {
			((Container) this.parent).isInitialized = false;
		}
		Screen scr = getScreen();
		if (scr != null && scr == StyleSheet.currentScreen) {
			scr.repaint(  );
		}
	}
	
	/**
	 * Repaints the screen to which this item belongs to depending on the isInitialized field
	 * When this item is initialized, only the area covered by this item is repainted (unless other repaint requests are queued).
	 * When this item is not initialized (isInitialized == false), a repaint for the complete screen is triggered, as there might be
	 * a size change involved.
	 * Subclasses can call this method whenever their contents have changed and they need an immediate refresh.
	 * 
	 * @see #isInitialized 
	 * @see #repaintFully()
	 * @see #repaint(int, int, int, int)
	 */
	protected void repaint() {
		//System.out.println("repaint(): " + this.relativeX + ", " + this.relativeY + ", " + this.itemWidth + ", " + this.itemHeight);
		if (this.isInitialized) {
			// note: -contentX, -contentY fails for right or center layouts
			repaint( - (this.paddingLeft + this.marginLeft + this.borderWidth), -(this.paddingTop + this.marginTop + this.borderWidth), this.itemWidth, this.itemHeight );
		} else {
			repaintFully();
		}
	}
	
	/**
	 * Repaints the specified relative area of this item.
	 * The area is specified relative to the <code>Item's</code>
	 * content area.
	 * 
	 * @param relX horizontal start position relative to this item's content area
	 * @param relY vertical start position relative to this item's content area
	 * @param width the width of the area
	 * @param height the height of the area
	 * 
	 * @see #repaint()
	 * @see #repaintFully()
	 */
	protected void repaint( int relX, int relY, int width, int height ) {
		//System.out.println("repaint called by class " + getClass().getName() );
		if (this.parent instanceof Container) {
			((Container) this.parent).isInitialized = false;
		}
		Item p = this;
		while (p != null) {
			relX += p.relativeX + p.contentX;
			relY += p.relativeY + p.contentY;
			if (p instanceof Container) {
				//System.out.println("yOffset of container: " + ((Container)p).yOffset + "  :   " + p );
				relY += ((Container)p).yOffset;
			}
			p = p.parent;
		}
		Screen scr = getScreen();
		if (scr != null && scr == StyleSheet.currentScreen) {
			//System.out.println("item.repaint(" + relX + ", " + relY+ ", " +  width + ", " +  height + ")  for " + this );
			scr.repaint( relX, relY, width, height );
		}
	}

	
	/**
	 * Requests that this item and all its parents are to be re-initialised at the next repainting.
	 * All parents of this item are notified, too.
	 * This method should be called when an item changes its size more than
	 * usual.
	 * When the item already has been initialised, a repaint() is requested, too.
	 */
	protected void requestInit() {
		//System.out.println("requestInit called by class " + getClass().getName() + " - screen.class=" + getScreen().getClass().getName()  );
		Item p = this.parent;
		while ( p != null) {
			p.isInitialized = false;
			p = p.parent;
		}
		if (this.isInitialized) {
			this.isInitialized = false;
			repaint();
		}
	}
	
	/**
	 * Retrieves the screen to which this item belongs to.
	 * 
	 * @return either the corresponding screen or null when no screen could be found 
	 */
	public Screen getScreen() {
		if (this.screen != null) {
			return this.screen;
		} else if (this.parent != null) {
			Item p = this.parent;
			while (p.parent != null) {
				p = p.parent;
			}
			return p.screen;
		} else {
			return null;
		}
	}

	/**
	 * Removes the context sensitive command from item. If the command is not
	 * in the <code>Item</code> (tested by comparing the object references),
	 * the method has
	 * no effect. If the <code>Item</code> is actually visible on the display,
	 * and this  call
	 * affects the set of visible commands, the implementation should update
	 * the display as soon as it is feasible to do so.
	 * 
	 * 
	 * If the command to be removed happens to be the default command,
	 * the command is removed and the default command on this Item is
	 * set to <code>null</code>.
	 * 
	 * The following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * is equivalent to the following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.setDefaultCommand(null);
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * 
	 * @param cmd - the command to be removed
	 * @since  MIDP 2.0
	 */
	public void removeCommand( Command cmd ) {
		if (this.commands != null) {
			if (cmd == this.defaultCommand) {
				this.defaultCommand = null;
			}
			if (this.commands.remove(cmd)) {
				if (this.isFocused) {
					Screen scr = getScreen();
					if (scr != null) {
						scr.removeCommand( cmd );
					}
				}
				if (this.isInitialized) {
					repaint();
				}
			}
		}
	}

	/**
	 * Sets a listener for <code>Commands</code> to this <code>Item</code>,
	 * replacing any previous
	 * <code>ItemCommandListener</code>. A <code>null</code> reference
	 * is allowed and has the effect of removing any existing listener.
	 * 
	 * When no listener is registered, J2ME Polish notifies the 
	 * command-listener of the current screen, when an item command 
	 * has been selected.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param l the new listener, or null.
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setItemCommandListener( ItemCommandListener l)
	{
		this.itemCommandListener = l;
	}

	/**
	 * Gets the preferred width of this <code>Item</code>.
	 * If the application has locked
	 * the width to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred height
	 * if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred width of the Item
	 * @see #getPreferredHeight()
	 * @see #setPreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getPreferredWidth()
	{
		return this.preferredWidth;
	}

	/**
	 * Gets the preferred height of this <code>Item</code>.
	 * If the application has locked
	 * the height to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred
	 * width if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred height of the Item
	 * @see #getPreferredWidth()
	 * @see #setPreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getPreferredHeight()
	{
		return this.preferredHeight;
	}

	/**
	 * Sets the preferred width and height for this <code>Item</code>.
	 * Values for width and height less than <code>-1</code> are illegal.
	 * If the width is between zero and the minimum width, inclusive,
	 * the minimum width is used instead.
	 * If the height is between zero and the minimum height, inclusive,
	 * the minimum height is used instead.
	 * 
	 * <p>Supplying a width or height value greater than the minimum width or
	 * height <em>locks</em> that dimension to the supplied
	 * value.  The implementation may silently enforce a maximum dimension for
	 * an <code>Item</code> based on factors such as the screen size.
	 * Supplying a value of
	 * <code>-1</code> for the width or height unlocks that dimension.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.</p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param width - the value to which the width should be locked, or -1 to unlock
	 * @param height - the value to which the height should be locked, or -1 to unlock
	 * @throws IllegalArgumentException - if width or height is less than -1
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getPreferredHeight()
	 * @see #getPreferredWidth()
	 * @since  MIDP 2.0
	 */
	public void setPreferredSize(int width, int height)
	{
		this.preferredHeight = height;
		this.preferredWidth = width;
	}

	/**
	 * Gets the minimum width for this <code>Item</code>.  This is a width
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum width of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumWidth()
	{
		return this.minimumWidth;
	}

	/**
	 * Gets the minimum height for this <code>Item</code>.  This is a height
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumHeight()
	{
		return this.minimumHeight;
	}

	/**
	 * Sets default <code>Command</code> for this <code>Item</code>.
	 * If the <code>Item</code> previously had a
	 * default <code>Command</code>, that <code>Command</code>
	 * is no longer the default, but it
	 * remains present on the <code>Item</code>.
	 * 
	 * <p>If not <code>null</code>, the <code>Command</code> object
	 * passed becomes the default <code>Command</code>
	 * for this <code>Item</code>.  If the <code>Command</code> object
	 * passed is not currently present
	 * on this <code>Item</code>, it is added as if <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
	 * had been called
	 * before it is made the default <code>Command</code>, unless the &quot;polish.Item.suppressDefaultCommand&quot; preprocessing variable is set to &quot;true&quot;.</p>
	 * 
	 * <p>If <code>null</code> is passed, the <code>Item</code> is set to
	 * have no default <code>Command</code>.
	 * The previous default <code>Command</code>, if any, remains present
	 * on the <code>Item</code>.
	 * </p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be used as this Item's default Command, or null if there is to be no default command
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setDefaultCommand( Command cmd)
	{
		//#if !polish.Item.suppressDefaultCommand
		if (this.defaultCommand != null && cmd != this.defaultCommand) {
			addCommand(this.defaultCommand);
		}
		//#endif		
		this.defaultCommand = cmd;
		//#if !polish.Item.suppressDefaultCommand
		if (cmd != null) {
			addCommand(cmd);
		}
		//#endif
	}

	/**
	 * Causes this <code>Item's</code> containing <code>Form</code> to notify
	 * the <code>Item's</code> <CODE>ItemStateListener</CODE>.
	 * The application calls this method to inform the
	 * listener on the <code>Item</code> that the <code>Item's</code>
	 * state has been changed in
	 * response to an action.  Even though this method simply causes a call
	 * to another part of the application, this mechanism is useful for
	 * decoupling the implementation of an <code>Item</code> (in particular, the
	 * implementation of a <code>CustomItem</code>, though this also applies to
	 * subclasses of other items) from the consumer of the item.
	 * 
	 * <p>If an edit was performed by invoking a separate screen, and the
	 * editor now wishes to &quot;return&quot; to the form which contained the
	 * selected <code>Item</code>, the preferred method is
	 * <code>Display.setCurrent(Item)</code>
	 * instead of <code>Display.setCurrent(Displayable)</code>,
	 * because it allows the
	 * <code>Form</code> to restore focus to the <code>Item</code>
	 * that initially invoked the editor.</p>
	 * 
	 * <p>In order to make sure that the documented behavior of
	 * <code>ItemStateListener</code> is maintained, it is up to the caller
	 * (application) to guarantee that this function is
	 * not called unless:</p>
	 * 
	 * <ul>
	 * <li>the <code>Item's</code> value has actually been changed, and</li>
	 * <li>the change was the result of a user action (an &quot;edit&quot;)
	 * and NOT as a result of state change via calls to
	 * <code>Item's</code> APIs </li>
	 * </ul>
	 * 
	 * <p>The call to <code>ItemStateListener.itemStateChanged</code>
	 * may be delayed in order to be serialized with the event stream.
	 * The <code>notifyStateChanged</code> method does not block awaiting
	 * the completion of the <code>itemStateChanged</code> method.</p>
	 * 
	 * @throws IllegalStateException if the Item is not owned by a Form
	 * @since  MIDP 2.0
	 */
	public void notifyStateChanged()
	{
		
		Screen scr = StyleSheet.currentScreen;
		if (scr == null || !(scr instanceof Form)) {
			scr = getScreen();
		}
		//#ifndef polish.skipArgumentCheck
			if ( (!(scr instanceof Form)) || (scr == null)) {
				//#ifdef polish.verboseDebug
					//# throw new IllegalStateException("notifyStateChanged() is valid only for items in Forms.");
				//#else
					throw new IllegalStateException();
				//#endif
			}
		//#endif
		((Form) scr).addToStateNotifyQueue(this);
	}
	
	/**
	 * Paints this item on the screen.
	 * This method should normally not be overriden. Override it
	 * only when you know what you are doing!
	 * 
	 * @param x the left start position of this item.
	 * @param y the top start position of this item.
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position,
	 * 		  rightBorder > x >= leftBorder
	 * @param g the Graphics on which this item should be painted.
	 */
	public void paint( int x, int y, int leftBorder, int rightBorder, Graphics g ) {
		// initialise this item if necessary:
		int availableWidth = rightBorder - leftBorder;
		int originalX = x;
		int originalY = y;
		if (!this.isInitialized || (availableWidth < this.itemWidth )) {
			//#if polish.debug.info
			//# if (availableWidth < this.itemWidth ) {
				//#debug info
				//# System.out.println("re-initializing item " + this + " for availableWidth=" + availableWidth + ", itemWidth=" + this.itemWidth);
			//# }
			//#endif
			init( rightBorder - x, availableWidth );
		}
		boolean isLayoutShrink = (this.layout & LAYOUT_SHRINK) == LAYOUT_SHRINK;

		// paint background and border when the label should be included in this:
		//#if polish.css.include-label
			//# if (this.includeLabel) {
				//# int width = this.itemWidth - this.marginLeft - this.marginRight;
				//# int height = this.itemHeight - this.marginTop - this.marginBottom;
				//# int bX = x + this.marginLeft;
				//# int bY = y + this.marginTop + this.backgroundYOffset;
				//# if ( this.background != null ) {
					//# this.background.paint(bX, bY, width, height, g);
				//# }
				//# if ( this.border != null ) {
					//# this.border.paint(bX, bY, width, height, g);
				//# }
			//# }
		//#endif
		
		// paint label:
		if (this.label != null) {
			if (this.useSingleRow) {
				this.label.paint( x, y, leftBorder, rightBorder - (this.contentWidth + this.paddingHorizontal), g );
				x += this.label.itemWidth;
				leftBorder += this.label.itemWidth;
			} else {
				this.label.paint( x, y, leftBorder, rightBorder, g );
				y += this.label.itemHeight;
			}
		}
		
		leftBorder += (this.marginLeft + this.borderWidth + this.paddingLeft);
		//#ifdef polish.css.before
			//# leftBorder += this.beforeWidth;
		//#endif
		//System.out.println( this.style.name + ":  increasing leftBorder by " + (this.marginLeft + this.borderWidth + this.paddingLeft));
		rightBorder -= (this.marginRight + this.borderWidth + this.paddingRight);
		//#ifdef polish.css.after
			//# rightBorder -= this.afterWidth;
		//#endif

		//System.out.println( this.style.name + ":  decreasing rightBorder by " + (this.marginRight + this.borderWidth + this.paddingRight));
		if ( this.isLayoutCenter  && availableWidth > this.itemWidth) {
			int difference = (availableWidth - this.itemWidth) / 2; 
			x += difference;
			if (isLayoutShrink) {
				leftBorder += difference;
				rightBorder -= difference;
				//System.out.println("item " + this + ": (center) shrinking left border to " + leftBorder + ", right border to " + rightBorder);
			}
		} else if ( this.isLayoutRight && availableWidth > this.itemWidth) {
			// adjust the x-position so that the item is painted up to
			// the right border (when it starts at x):
			x += availableWidth - this.itemWidth;
			if (isLayoutShrink) {
				leftBorder += availableWidth - this.itemWidth;
				//System.out.println("item " + this + ": (right) shrinking left border to " + leftBorder);
			}
		} else if (isLayoutShrink && availableWidth > this.itemWidth) {
			rightBorder -= availableWidth - this.itemWidth;
			//System.out.println("item " + this + ": (left) shrinking right border to " + rightBorder);
		}
		
		// paint background:
		x += this.marginLeft;
		y += this.marginTop;
		//#if polish.css.include-label
			//# if (!this.includeLabel) {
		//#endif
				if (this.background != null) {
					this.background.paint(x, y + this.backgroundYOffset, this.backgroundWidth, this.backgroundHeight, g);
				}
				// paint border:
				if (this.border != null) {
					this.border.paint(x, y + this.backgroundYOffset, this.backgroundWidth, this.backgroundHeight, g);
				}
		//#if polish.css.include-label
			//# }
		//#endif
		
		x += this.borderWidth + this.paddingLeft;
		y += this.borderWidth + this.paddingTop;
		int originalContentY = y;
		
		// paint before element:
		//#if polish.css.before || polish.css.after || polish.css.min-height  || polish.css.max-height
			//# boolean isVerticalCenter = (this.layout & LAYOUT_VCENTER) == LAYOUT_VCENTER; 
			//# boolean isTop = !isVerticalCenter && (this.layout & LAYOUT_TOP) == LAYOUT_TOP; 
			//# boolean isBottom = !isVerticalCenter && (this.layout & LAYOUT_BOTTOM) == LAYOUT_BOTTOM; 
		//#endif
		//#if polish.css.min-height
			//# if (this.minimumHeight != 0) {
				//# int minHeight = this.minimumHeight - ( 2 * this.borderWidth + this.marginTop + this.marginBottom + this.paddingTop + this.paddingBottom);
				//# if ( isVerticalCenter ) {
//# //					System.out.println("vertical: adjusting contY by " + ((this.minimumHeight - this.contentHeight) / 2)
//# //							+ ", contentHeight=" + this.contentHeight + ", minHeight=" + this.minimumHeight );
					//# y += (minHeight - this.contentHeight) / 2; 
				//# } else if ( isBottom ) {
					//# //System.out.println("bottom: adjusting contY by " + (this.minimumHeight - this.contentHeight) );
					//# y += (minHeight - this.contentHeight);
				//# }
			//# }
		//#endif
		//#ifdef polish.css.before
			//# if (this.beforeImage != null) {
				//# int beforeY = y;
				//# int yAdjustment = this.beforeHeight - this.contentHeight;
				//# if ( this.beforeHeight < this.contentHeight) {
					//# if (isTop) {
						//# beforeY -= yAdjustment;
					//# } else if (isBottom) {
						//# beforeY += yAdjustment;
					//# } else {
						//# beforeY -= yAdjustment / 2;
					//# }
				//# } else {
					//# if (isTop) {
						//# // keep contY
					//# } else if (isBottom) {
						//# y += yAdjustment;
					//# } else {
						//# y += yAdjustment / 2;
					//# }
					//# //contY += (this.beforeHeight - this.contentHeight) / 2;
				//# }
				//# g.drawImage(this.beforeImage, x, beforeY, Graphics.TOP | Graphics.LEFT );
				//# x += this.beforeWidth;
			//# }
		//#endif
		
		// paint after element:
		//#ifdef polish.css.after
			//# if (this.afterImage != null) {
				//# int afterY = originalContentY;
				//# int yAdjustment = this.afterHeight - this.contentHeight;
				//# if ( this.afterHeight < this.contentHeight) {
					//# if (isTop) {
						//# afterY -= yAdjustment;
					//# } else if (isBottom) {
						//# afterY += yAdjustment;
					//# } else {
						//# afterY -= yAdjustment / 2;
					//# }
					//# //afterY += (this.contentHeight - this.afterHeight) / 2;
				//# } else {
					//#ifdef polish.css.before
					//# if (this.afterHeight > this.beforeHeight) {
					//#endif
						//# if (isTop) {
							//# // keep contY
						//# } else if (isBottom) {
							//# y = originalContentY + yAdjustment;
						//# } else {
							//# y = originalContentY + yAdjustment / 2;
						//# }
						//# //contY = originalContentY + (this.afterHeight - this.contentHeight) / 2;
					//#ifdef polish.css.before
					//# }
					//#endif
				//# }
				//# g.drawImage(this.afterImage, rightBorder, afterY, Graphics.TOP | Graphics.LEFT );
			//# }
		//#endif
		

		// paint content:
		this.contentX = x - originalX;
		this.contentY = y - originalY;
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.paintContent( this, x, y, leftBorder, rightBorder, g);
			} else {
		//#endif
				paintContent( x, y, leftBorder, rightBorder, g );				
		//#ifdef polish.css.view-type
			}
		//#endif
	}
	
	/**
	 * Initialises this item.
	 * You should always call super.init( firstLineWidth, lineWidth) when overriding this method.
	 * This method call either ItemView.initContent() or Item.initContent() to initialize the actual content.
	 * A valid case for overriding would be if additional initialization needs to be done even when an
	 * ItemView is associated with this Item. Usually implementing initContent() should suffice.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @see #initContent(int, int)
	 * @see ItemView#initContent(Item, int, int)
	 */
	protected void init( int firstLineWidth, int lineWidth ) {
		//#debug
		//# System.out.println("intialising item " + this.getClass().getName() + " (" + this + ")");
		if (this.style != null && !this.isStyleInitialised) {
			setStyle( this.style );
		}
		//#ifdef polish.useDynamicStyles
			//# else if (this.style == null) {
				//# initStyle();
			//# }
		//#else
			else if (this.style == null && !this.isStyleInitialised) {
				//#debug
				//# System.out.println("Setting default style for item " + getClass().getName() );
				setStyle( StyleSheet.defaultStyle );
			}
		//#endif
		int labelWidth = 0;
		int labelHeight = 0;
		if (this.label != null) {
			if (!this.label.isInitialized) {
				this.label.init( firstLineWidth, lineWidth );
			}
			labelWidth = this.label.itemWidth;
			labelHeight = this.label.itemHeight;
		}
		// calculate content width and content height:
		int noneContentWidth =  
			 	this.marginLeft + this.borderWidth + this.paddingLeft 
				+ this.paddingRight + this.borderWidth + this.marginRight;
		//#ifdef polish.css.before
			//# noneContentWidth += this.beforeWidth;
		//#endif
		//#ifdef polish.css.after
			//# noneContentWidth += this.afterWidth;
		//#endif
		/*
		if (noneContentWidth >= firstLineWidth) {
			System.out.println("INVALID NONE CONTENT WIDTH=" + noneContentWidth);
		}
		*/
		//#ifdef polish.css.max-width
			//# int firstLineAdjustedWidth = firstLineWidth;
			//# int lineAdjustedWidth = lineWidth;
			//# if (this.maximumWidth != 0 ) {
				//# if (firstLineAdjustedWidth > this.maximumWidth ) {
					//# firstLineAdjustedWidth = this.maximumWidth;
				//# } 
				//# if (lineAdjustedWidth > this.maximumWidth ) {
					//# lineAdjustedWidth = this.maximumWidth;
				//# }
			//# }
			//# int firstLineContentWidth = firstLineAdjustedWidth - noneContentWidth;
			//# int availableContentWidth = lineAdjustedWidth - noneContentWidth;
		//#else
			int firstLineContentWidth = firstLineWidth - noneContentWidth;
			int availableContentWidth = lineWidth - noneContentWidth;
		//#endif
		
		// initialise content by subclass:
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.initContent(this, firstLineContentWidth, availableContentWidth);
				this.contentWidth = this.view.contentWidth;
				this.contentHeight = this.view.contentHeight;
			} else {
		//#endif
				initContent( firstLineContentWidth, availableContentWidth );
		//#ifdef polish.css.view-type
			}
		//#endif
		
		if (this.contentWidth == 0 && this.contentHeight == 0) {
			this.itemWidth = labelWidth;
			this.itemHeight = labelHeight;
			this.backgroundHeight = 0;
			this.backgroundWidth = 0;
			this.isInitialized = true;
			return;
		}
		
		this.itemWidth = noneContentWidth + this.contentWidth;
		//#ifdef polish.css.min-width
			//# if (this.itemWidth < this.minimumWidth ) {
				//# this.itemWidth = this.minimumWidth;
			//# }
		//#endif
		//#ifdef polish.css.max-width
			//# if (this.maximumWidth != 0 && this.itemWidth > this.maximumWidth ) {
				//# this.itemWidth = this.maximumWidth;
			//# }
		//#endif
		int cHeight = this.contentHeight;
		//#ifdef polish.css.before
			//# if (this.contentHeight < this.beforeHeight) {
				//# cHeight = this.beforeHeight;
			//# }
		//#endif
		//#ifdef polish.css.after
			//# if (this.contentHeight < this.afterHeight) {
				//# cHeight = this.afterHeight;
			//# }
		//#endif
		int noneContentHeight = this.marginTop + this.borderWidth + this.paddingTop 
			  + this.paddingBottom + this.borderWidth + this.marginBottom;
		if (this.itemWidth + labelWidth <= lineWidth) {
			// label and content fit on one row:
			this.useSingleRow = true;
			if (this.label != null) {
				if ( (this.label.layout & LAYOUT_NEWLINE_AFTER) != 0 || ((this.layout & LAYOUT_NEWLINE_BEFORE) == LAYOUT_NEWLINE_BEFORE )) {
					this.useSingleRow = false;
					cHeight += labelHeight;
				}
			}
			if (this.useSingleRow) {
				this.itemWidth += labelWidth;				
			}
			if ( cHeight + noneContentHeight < labelHeight ) {
				cHeight = labelHeight - noneContentHeight;
			}
		} else {
			this.useSingleRow = false;
			cHeight += labelHeight;
		}
		if ( this.isLayoutExpand ) {
			this.itemWidth = lineWidth;
			//#ifdef polish.css.max-width
				//# if (this.maximumWidth != 0 && lineWidth > this.maximumWidth ) {
					//# this.itemWidth = this.maximumWidth;
				//# }
			//#endif
		} else if (this.itemWidth > lineWidth) {
			this.itemWidth = lineWidth;
		}
		if (cHeight + noneContentHeight < this.minimumHeight) {
			cHeight = this.minimumHeight - noneContentHeight;
		}
		//#if polish.css.max-height
			//# if (this.maximumHeight != 0 && cHeight + noneContentHeight > this.maximumHeight) {
				//# cHeight = this.maximumHeight - noneContentHeight;
			//# }
		//#endif
		this.itemHeight = cHeight + noneContentHeight;
		if (this.useSingleRow) {
			this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight - labelWidth;
			this.backgroundHeight = cHeight
							  + noneContentHeight
							  - this.marginTop
							  - this.marginBottom;
		} else {
			this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight;
			this.backgroundHeight = cHeight
							  + noneContentHeight
							  - this.marginTop
							  - this.marginBottom
							  - labelHeight;
		}
		this.isInitialized = true;
		//#debug
		//# System.out.println("Item.init(): contentWidth=" + this.contentWidth + ", itemWidth=" + this.itemWidth + ", backgroundWidth=" + this.backgroundWidth);
	}
	
	//#ifdef polish.useDynamicStyles
	//# /**
	 //# * Initialises the appropriate style for this item.
	 //# */
	//# protected void initStyle() {
		//# //System.out.println("item [" + this.getClass().getName() + "/" + this.cssSelector + "/" + this.hashCode() + "] has been initalised: " + this.isStyleInitialised );
		//# if (this.screen == null) {
			//# if (this.parent != null) {
				//# this.screen = getScreen();
			//# } else {
				//# this.screen = StyleSheet.currentScreen;
			//# }
		//# }
		//# if (this.style == null) {
			//# this.cssSelector = createCssSelector();
			//#debug
			//# System.out.println("getting style for item [" + this.cssSelector + "].");
			//# setStyle( StyleSheet.getStyle( this ) );
		//# } else {
			//# //System.out.println("item has already style [" + this.style.name + "].");
			//# this.cssSelector = this.style.name;
		//# }
		//# this.isStyleInitialised = true;
	//# }
	//#endif
	

	/**
	 * Initialises this item. 
	 * The implementation needs to calculate and set the contentWidth and 
	 * contentHeight fields. 
	 * The implementation should take the fields preferredWidth and preferredHeight
	 * into account.
	 * 
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @see #contentWidth
	 * @see #contentHeight
	 * @see #preferredWidth
	 * @see #preferredHeight
	 */
	protected abstract void initContent(int firstLineWidth, int lineWidth);
	
	
	/**
	 * Paints the content of this item.
	 * The background has already been painted and the border will be added after
	 * this method returns.
	 * 
	 * @param x the left start position
	 * @param y the upper start position
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position
	 * @param g the Graphics on which this item should be painted.
	 */
	protected abstract void paintContent( int x, int y, int leftBorder, int rightBorder, Graphics g );
	
	//#ifdef polish.useDynamicStyles	
	//# /**
	 //# * Retrieves the CSS selector for this item.
	 //# * The CSS selector is used for the dynamic assignment of styles -
	 //# * that is the styles are assigned by the usage of the item and
	 //# * not by a predefined style-name.
	 //# * With the #style preprocessing command styles are set fix, this method
	 //# * yields in a faster GUI and is recommended. When in a style-sheet
	 //# * dynamic styles are used, e.g. "Form>p", than the selector of the
	 //# * item is needed.
	 //# * <br/>
	 //# * This abstract method needs only be implemented, when dynamic styles
	 //# * are used: #ifdef polish.useDynamicStyles
	 //# * <br/>
	 //# * The returned selector needs to be in lower case. 
	 //# * 
	 //# * @return the appropriate CSS selector for this item.
	 //# * 			The selector needs to be in lower case.
	 //# */
	//# protected abstract String createCssSelector();	
	//#endif

	/**
	 * Handles the key-pressed event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation just handles the FIRE game-action
	 * when a default-command and an item-command-listener have been
	 * registered.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 */
	protected boolean handleKeyPressed( int keyCode, int gameAction ) {
		//#debug
		//# System.out.println("item " + this + ": handling keyPressed for keyCode=" + keyCode + ", gameAction=" + gameAction);
		Item item = this;
		if (this.defaultCommand == null && this.parent != null) {
			item = this.parent;
		}
		if ((gameAction == Canvas.FIRE) 
				&& (item.defaultCommand != null)
				&& (item.itemCommandListener != null)) {
			item.itemCommandListener.commandAction(item.defaultCommand, this);
			return true;
		}
		return false;
	}
	
	/**
	 * Handles the key-repeated event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation forwards the event to the handleKeyPressed method.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 * @see #handleKeyPressed(int, int)
	 */
	protected boolean handleKeyRepeated( int keyCode, int gameAction ) {
		return handleKeyPressed(keyCode, gameAction);
	}
	
	/**
	 * Handles the key-released event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default does nothing.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 * @see #handleKeyPressed(int, int)
	 */
	protected boolean handleKeyReleased( int keyCode, int gameAction ) {
		return false;
	}

	
	/**
	 * Determines whether the given relative x/y position is inside of this item's content area.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method or possibly the getContentX(), getContentY() methods.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's content area.
	 * @see #initContent(int, int)
	 */
	public boolean isInContentArea( int relX, int relY ) {
		int contTop = this.contentY;
		if ( relY < contTop || relY > contTop + this.contentHeight ) {
			return false;
		}
		int contLeft = this.contentX;
		if (relX < contLeft || relX > contLeft + this.contentWidth) {
			return false;
		}
		return true;
	}

	/**
	 * Determines whether the given relative x/y position is inside of this item's area including paddings, margins and label.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's area.
	 * @see #initContent(int, int)
	 */
	public boolean isInItemArea( int relX, int relY ) {
		// problem:
		// itemWidth can be smaller than the available width - when then a center or right layout is used, then this fucks up...
		if (relY < 0 || relY > this.itemHeight || relX < 0 || relX > this.itemWidth) {
			//#debug
			//# System.out.println("isInItemArea(" + relX + "," + relY + ") = false: itemWidth=" + this.itemWidth + ", itemHeight=" + this.itemHeight + " (" + this + ")");
			return false;
		}
		//#debug
		//# System.out.println("isInItemArea(" + relX + "," + relY + ") = true: itemWidth=" + this.itemWidth + ", itemHeight=" + this.itemHeight + " (" + this + ")");
		return true;
	}
	
	//#ifdef polish.hasPointerEvents
	//# /**
	 //# * Handles the event when a pointer has been pressed at the specified position.
	 //# * The default method discards this event when relX/relY is outside of the item's area.
	 //# * When the event took place inside of the content area, the pointer-event is translated into an artificial
	 //# * FIRE game-action keyPressed event, which is subsequently handled
	 //# * bu the handleKeyPressed(-1, Canvas.FIRE) method.
	 //# * This method needs should be overwritten only when the "polish.hasPointerEvents"
	 //# * preprocessing symbol is defined: "//#ifdef polish.hasPointerEvents".
	 //# *    
	 //# * @param relX the x position of the pointer pressing relative to this item's left position
	 //# * @param relY the y position of the pointer pressing relative to this item's top position
	 //# * @return true when the pressing of the pointer was actually handled by this item.
	 //# * @see #isInItemArea(int, int) this method is used for determining whether the event belongs to this item
	 //# * @see #isInContentArea(int, int) for a helper method for determining whether the event took place into the actual content area
	 //# * @see #handleKeyPressed(int, int) 
	 //# * @see #contentX for calculating the horizontal position relative to the content (relX - contentX)
	 //# * @see #contentY for calculating the vertical position relative to the content (relY - contentY)
	 //# */
	//# protected boolean handlePointerPressed( int relX, int relY ) {
		//# if ( isInItemArea(relX, relY)) {
			//# return handleKeyPressed( -1, Canvas.FIRE );
		//# }
		//# return false;
	//# }
	//#endif
	
	/**
	 * Animates this item.
	 * Subclasses can override this method to create animations.
	 * The default implementation animates the background and the item view if present.
	 * 
	 * @return true when this item has been animated.
	 */
	public boolean animate() {
		boolean animated = false;
		if (this.background != null) {
			animated = this.background.animate();
		}
		//#if polish.css.view-type
			if (this.view != null) {
				animated |= this.view.animate();
			}
		//#endif
		return animated;
	}
	
	/**
	 * Retrieves the approriate style for focusing this item.
	 * This is either a item specific one or one inherit by its parents.
	 * When no parent has a specific focus style, the StyleSheet.focusedStyle is used.
	 * 
	 * @return the style used for focussing this item.
	 */
	public Style getFocusedStyle() {
		if (this.focusedStyle != null) {
			return this.focusedStyle;
		} else if (this.parent != null) {
			return this.parent.getFocusedStyle();
		} else {
			return StyleSheet.focusedStyle;
		}
	}

	/**
	 * Focuses this item.
	 * 
	 * @param newStyle the style which is used to indicate the focused state
	 * @param direction the direction from which this item is focused,
	 *        either Canvas.UP, Canvas.DOWN, Canvas.LEFT, Canvas.RIGHT or 0.
	 *        When 0 is given, the direction is unknown.
	 * @return the current style of this item
	 */
	protected Style focus( Style newStyle, int direction ) {
		Style oldStyle = this.style;
		if (this.focusedStyle != null) {
			newStyle = this.focusedStyle;
		} 
		setStyle( newStyle );
		this.isFocused = true;
		// now set any commands of this item:
		if (this.commands != null) {
			Screen scr = getScreen();
			if (scr != null) {
				scr.setItemCommands(this);
			}
		}
		// when an item is focused, it usually grows bigger, so
		// increase the bottom position a bit:
		this.itemHeight += 5;
		if (oldStyle == null) {
			oldStyle = StyleSheet.defaultStyle;
		}
		return oldStyle;
	}
	
	/**
	 * Removes the focus from this item.
	 * 
	 * @param originalStyle the original style which will be restored.
	 */
	protected void defocus( Style originalStyle ) {
		this.backgroundYOffset = 0;
		if (originalStyle != null) {
			setStyle( originalStyle );
		} else {
			this.background = null;
			this.border = null;
			this.style = null;
		}
		this.isFocused = false;
		// now remove any commands which are associated with this item:
		if (this.commands != null) {
			Screen scr = getScreen();
			if (scr != null) {
				scr.removeItemCommands(this);
			}
		}
	}

	/**
	 * Called by the system to notify the item that it is now at least
	 * partially visible, when it previously had been completely invisible.
	 * The item may receive <code>paint()</code> calls after
	 * <code>showNotify()</code> has been called.
	 * 
	 * <p>The default implementation of this method does nothing.</p>
	 */
	protected void showNotify()
	{
		//default implementation does nothing
	}

	/**
	 * Called by the system to notify the item that it is now completely
	 * invisible, when it previously had been at least partially visible.  No
	 * further <code>paint()</code> calls will be made on this item
	 * until after a <code>showNotify()</code> has been called again.
	 * 
	 * <p>The default implementation of this method does nothing.</p>
	 */
	protected void hideNotify()
	{
		//default implementation does nothing
	}
	
	/**
	 * Shows the screen to which item belongs to and focusses this item.
	 * This method is the equivalent to display.setCurrentItem( item ).
	 * 
	 * @param display the display of the MIDlet.
	 */
	public void show( Display display ) {
		Screen myScreen = getScreen();
		if ( myScreen == null ) {
			//#debug warn
			//# System.out.println("Unable to show this item, since the screen is not known.");
			return;
		}
		
		myScreen.focus( this );
		display.setCurrent( myScreen );
	}
	
	/**
	 * Releases all (memory intensive) resources such as images or RGB arrays of this item.
	 * The default implementation releases any background resources.
	 */
	public void releaseResources() {
		if (this.background != null) {
			this.background.releaseResources();
		}
	}

	/**
	 * Sets an arbitrary attribute for this item.
	 * 
	 * @param key the key for the attribute
	 * @param value the attribute value
	 */
	public void setAttribute( Object key, Object value ) {
		if (this.attributes == null) {
			this.attributes = new HashMap();
		}
		this.attributes.put( key, value );
	}
	
	/**
	 * Gets an previously added attribute of this item.
	 * 
	 * @param key the key of the attribute
	 * @return the attribute value, null if none has been registered under the given key before
	 */
	public Object getAttribute( Object key ) {
		if (this.attributes == null) {
			return null;
		}
		return this.attributes.get( key );
	}
  
  /**
   * Returns a HashMap object with all registered attributes.
   * 
   * @return a HashMap object with all attribute key/value pairs, null if no attribute was stored before.
   */
  public HashMap getAttributes() {
    return this.attributes;
  }
	

//#ifdef polish.Item.additionalMethods:defined
	//#include ${polish.Item.additionalMethods}
//#endif

}
